<!DOCTYPE html>
<html lang="en-US">
<head>
    <meta charset="utf-8" />
    <title>Sample</title>

    <link href="https://cdn01.boxcdn.net/platform/elements/11.0.2/ja-JP/openwith.css" rel="stylesheet" type="text/css"></link>
    <link href="https://cdn01.boxcdn.net/platform/preview/2.34.0/ja-JP/preview.css" rel="stylesheet" type="text/css"></link>

    <script src="https://cdn.polyfill.io/v2/polyfill.min.js?features=es6,Intl"></script>
    <script src="https://cdn01.boxcdn.net/polyfills/core-js/2.5.3/core.min.js"></script>

    <script src="https://cdn01.boxcdn.net/platform/elements/11.0.2/ja-JP/openwith.js"></script>
    <script src="https://cdn01.boxcdn.net/platform/preview/2.34.0/ja-JP/preview.js"></script>

    <!-- axiosを導入 -->
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>

    <style>
        .openwith-container {
            margin-left: 250px;
        }
        .preview-container {
            height: 800px;
            width: 100%;
        }
    </style>

</head>
<body>
<h3>File Id: <%= fileId %></h3>

<div id="container">
    <div class="openwith-container"></div>
    <div class="preview-container"></div>
</div>

<script>
    // app.jsから渡されたパラメータ
    window.fileId = "<%= fileId %>"
    window.token = "<%= token %>"

    const openWith = new Box.ContentOpenWith();
    openWith.show(fileId, token,  { container: ".openwith-container"})

    window.preview = new Box.Preview();
    preview.show(fileId, token, { container: ".preview-container", autoFocus: false });




    openWith.addListener("execute", async () => {
        // openWithが開かれたので、ロングポーリング開始

        // リアルタイムサーバー取得
        const optionsRes = await fetch("https://api.box.com/2.0/events", {
            method: "OPTIONS",
            headers: {
                "Content-Type": "application/json; charset=utf-8",
                "Authorization": `Bearer ${token}`,
            }
        });
        const optionsJRes = await optionsRes.json();

        let lastSequenceId = 0;
        const subscribe = async (streamPosition = "now") => {
            // リアルタイムサーバーに対してロングポーリングを行う
            // CORSエラーを避けるる設定で行う
            console.log(`requesting ${optionsJRes.entries[0].url}`);
            let rtsRes = await fetch(optionsJRes.entries[0].url, {
                method: "GET",
                mode: "no-cors",
                headers: {
                    "Content-Type": "application/x-www-form-urlencoded"
                }
            })

            // ロングポーリングからはtype: "opaque"というのが帰ってくるのだけど、、よくわからない。。
            // とはいえ、応答が帰ってくると、何かのイベントが発生したことはわかる。
            console.log("rtServer res", rtsRes)

            //　何かのイベントが発生したので、EventAPIをGETで叩き、詳細情報を取り出す
            const qs = new URLSearchParams();
            qs.set("event_type", "ITEM_UPLOAD"); // 更新だけに絞る
            qs.set("stream_type", "sync");
            qs.set("stream_position", streamPosition); // 初回は"now", 2回め以降はnext_stream_positionが入る
            console.log(`requesting https://api.box.com/2.0/events?${qs.toString()}`);
            const getRes = await fetch(`https://api.box.com/2.0/events?${qs.toString()}`, {
                method: "GET",
                headers: {
                    "Content-Type": "application/json; charset=utf-8",
                    "Authorization": `Bearer ${token}`,
                }
            });
            const getJRes = await getRes.json();

            console.log("getJRes", getJRes)
            // 対象のFileIDが更新されているかチェック
            // 日付もチェックしようとおもったが、どうも帰ってくる更新日付が怪しいので今回はチェックしない
            const updated = getJRes.entries.some(event => {
                return event.event_type === "ITEM_UPLOAD"
                    && event.source
                    && event.source.type === "file"
                    && event.source.id === fileId
            })

            // 複数もどってくるイベントを、対象ファイルの更新のもので、最新のものに絞る
            const latestEvent = getJRes.entries.reduce((acc, cur) => {
                if(cur.event_type === "ITEM_UPLOAD"
                    && cur.source
                    && cur.source.type === "file"
                    && cur.source.id === fileId) {
                    if(acc && acc.sequence_id < cur.sequence_id) {
                        return cur;
                    } else {
                        return acc;
                    }
                }
            })

            // 前回処理したイベントより先に行ってるときだけリロードする
            if(latestEvent && latestEvent.sequence_id > lastSequenceId) {

                //　今回処理するイベントのsequence_idを保存
                lastSequenceId = latestEvent.sequence_id;

                // previewだけを描画し直す。
                preview = new Box.Preview(); // preivewオブジェクトは再利用できないっぽい。再度newする必要があるみたい。
                // 毎回プレビューの位置までスクロールされたくないのでautoFocus:false
                preview.show(fileId, token, { container: ".preview-container", autoFocus: false });
            }

            // Update されていることがわかったのでPreviewを更新
            // if(updated || streamPosition === "now") {
            //     // previewだけを描画し直す。
            //     preview = new Box.Preview(); // preivewオブジェクトは再利用できないっぽい。再度newする必要があるみたい。
            //     // 毎回プレビューの位置までスクロールされたくないのでautoFocus:false
            //     preview.show(fileId, token, { container: ".preview-container", autoFocus: false });
            // }

            // console.log("getJRes", getJRes)

            await subscribe(getJRes.next_stream_position)
        }
        await subscribe();
    })

</script>
</body>
</html>
